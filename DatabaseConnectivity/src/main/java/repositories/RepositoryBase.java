package repositories;

import dtos.DTOBase;
import exception.CustomException;
import repositories.interfaces.IRepository;
import java.sql.*;
import java.time.*;
import java.util.List;

/**
 * This class provides a skeletal implementation of the {@link IRepository}
 * interface to minimize the effort required to implement this interface.
 */

public abstract class RepositoryBase<TDTO extends DTOBase> implements IRepository<TDTO> {

    private final Connection connection;

    protected RepositoryBase(Connection connection) {
        this.connection = connection;
    }

    /**
     * Returns the name of the corresponding entity for the repository.
     *
     * @return a string containing the name of the
     *         corresponding entity for the repository
     */
    protected abstract String getTableName();

    /**
     * Returns the entity column names for the repository.
     *
     * @return a new {@link List<String>}
     */
    protected abstract List<String> getColumnsName();

    /**
     * Returns values of all columns of the entity record except the primary key.
     *
     * @param dto - representing the entity record
     *
     * @return a new {@link List}
     */
    protected abstract List<Object> getParameters(TDTO dto);

    /**
     * Returns an object representing the entity record retrieved
     * as a result of the query.
     *
     * @param resultSet - a table of data representing a database result set, which
     * generated by executing a statement that queries the database
     *
     * @return a <TDTO extends {@link DTOBase}> object representing
     *         the entity record retrieved as a result of the query
     */
    protected abstract TDTO getDTO(ResultSet resultSet) throws SQLException;

    @Override
    public final Connection getConnection() {
        return connection;
    }

    @Override
    public void beginTransaction() {
        try {
            connection.setAutoCommit(false);
        } catch (SQLException sqlException) {
            String message = sqlException.getMessage();
            throw new CustomException(message, sqlException);
        }
    }

    @Override
    public void commitTransaction() {
        try {
            connection.commit();
        } catch (SQLException sqlException) {
            String message = sqlException.getMessage();
            throw new CustomException(message, sqlException);
        }
    }

    @Override
    public void rollbackTransaction() {
        try {
            connection.rollback();
        } catch (SQLException sqlException) {
            String message = sqlException.getMessage();
            throw new CustomException(message, sqlException);
        }
    }

    @Override
    public void add(TDTO dto) {
        try {
            List<Object> parameters = getParameters(dto);
            final String addCommand = "INSERT INTO " + getTableName() + getValuesPart(parameters.size());
            PreparedStatement preparedStatement = connection.prepareStatement(addCommand);
            preparedStatement.setInt(1, dto.getId());
            setPreparedStatementParameters(preparedStatement, parameters, true);
            preparedStatement.executeUpdate();
        } catch (Throwable exception) {
            String message = exception.getMessage();
            throw new CustomException(message, exception);
        }
    }

    @Override
    public void update(TDTO dto) {
        if(findById(dto.getId()) == null)
            throw new CustomException("Record with key value(" + dto.getId() +
                    ") doesn't exist in " + dto.getClass().getSimpleName() + " object");
        try {
            List<Object> parameters = getParameters(dto);
            final String ID = getColumnsName().get(0);
            final String updateCommand = "UPDATE " + getTableName() + getSetPart() +
                                         " WHERE " + ID + " = ?;";
            PreparedStatement preparedStatement = connection.prepareStatement(updateCommand);
            setPreparedStatementParameters(preparedStatement, parameters, false);
            preparedStatement.setInt(parameters.size() + 1, dto.getId());
            preparedStatement.executeUpdate();
        } catch (Throwable exception){
            String message = exception.getMessage();
            throw new CustomException(message, exception);
        }
    }

    @Override
    public void delete(TDTO dto) {
        if(findById(dto.getId()) == null)
            throw new CustomException("Record with key value(" + dto.getId() +
                    ") doesn't exist in " + dto.getClass().getSimpleName() + " object");
        if(!dto.equals(findById(dto.getId())))
            return;
        try {
            final String ID = getColumnsName().get(0);
            final String deleteCommand = "DELETE FROM " + getTableName() +
                                         " WHERE " + ID + " = ?";
            PreparedStatement preparedStatement = connection.prepareStatement(deleteCommand);
            preparedStatement.setInt(1, dto.getId());
            preparedStatement.executeUpdate();
        } catch (Throwable exception){
            String message = exception.getMessage();
            throw new CustomException(message, exception);
        }
    }

    @Override
    public TDTO findById(int id) {
        TDTO dto = null;
        try {
            final String ID = getColumnsName().get(0);
            final String findCommand = getSelectPart() +
                                       " FROM " + getTableName() +
                                       " WHERE " + ID + " = ?";
            PreparedStatement preparedStatement = connection.prepareStatement(findCommand);
            preparedStatement.setInt(1, id);
            ResultSet resultSet = preparedStatement.executeQuery();
            if(resultSet.next() && resultSet.getRow() != 0)
                dto = getDTO(resultSet);
        } catch (Throwable exception){
            String message = exception.getMessage();
            throw new CustomException(message, exception);
        }
        return dto;
    }

    public int getRowsCount() {
        int rowsCount = 0;
        try {
            final String countCommand = "SELECT COUNT(1)" +
                                        " FROM " + getTableName() + ";";
            PreparedStatement preparedStatement = connection.prepareStatement(countCommand);
            ResultSet resultSet = preparedStatement.executeQuery();
            if(resultSet.next() && resultSet.getRow() != 0)
                rowsCount =  resultSet.getInt(1);
        } catch (Throwable exception){
            String message = exception.getMessage();
            throw new CustomException(message, exception);
        }
        return rowsCount;
    }

    /**
     * Returns the VALUES(?,?...) part of the statement.
     *
     * @param numberOfParameters - number of values for the new record
     *
     * @return a string containing the VALUES(?,?...) part of
     *         the statement for adding records to the repository
     */
    private String getValuesPart(int numberOfParameters){
        if(numberOfParameters <= 0)
            return null;
        StringBuilder result = new StringBuilder(" VALUES(?, ");
        for (int counter = 1; counter <= numberOfParameters; counter++)
            result.append(counter != numberOfParameters ? "?, " : "?);");
        return result.toString();
    }

    /**
     * Returns the SET part of the statement.
     *
     * @return a string containing the SET part of the
     *         statement for updating records in the repository
     */
    private String getSetPart(){
        List<String> columns = getColumnsName();
        StringBuilder result = new StringBuilder(" SET ");
        for (int columnIndex = 1; columnIndex < columns.size(); columnIndex++)
            result.append(columns.get(columnIndex))
                    .append(columnIndex == columns.size() - 1 ? " = ?" :" = ?, ");
        return result.toString();
    }

    /**
     * Returns the SELECT part of the query.
     *
     * @return a string containing the SELECT part of the
     *         query to retrieve entries from the repository
     */
    private String getSelectPart(){
        List<String> columns = getColumnsName();
        StringBuilder result = new StringBuilder("SELECT ");
        for (int columnIndex = 0; columnIndex < columns.size(); columnIndex++) {
            result.append(columns.get(columnIndex));
            if(columnIndex != columns.size() - 1)
                result.append(", ");
        }
        return result.toString();
    }

    /**
     * Sets the corresponding parameters to the statement.
     *
     * @param preparedStatement - statement into which the parameters are written
     * @param parameters - a list of parameter values to be written in the statement
     * @param hasIdParameter - if this parameter is true, the list of parameter values
     *                         are written in an statement starting at parameterIndex = 2.
     *                         Otherwise, parameters values are written in the statement
     *                         starting with parameterIndex = 1
     */
    private void setPreparedStatementParameters(PreparedStatement preparedStatement,
                                                List<Object> parameters,
                                                boolean hasIdParameter) throws SQLException {
        int shift, parameterIndex = shift = hasIdParameter ? 2 : 1;
        int size = hasIdParameter ? parameters.size() + 1 : parameters.size();
        while (parameterIndex <= size) {
            Object parameter = parameters.get(parameterIndex - shift);
            if (parameter instanceof Number)
                preparedStatement.setInt(parameterIndex++, (Integer) parameter);
            else if (parameter instanceof LocalDate)
                preparedStatement.setDate(parameterIndex++, Date.valueOf((LocalDate) parameter));
            else if (parameter instanceof LocalDateTime)
                preparedStatement.setTimestamp(parameterIndex++, Timestamp.valueOf((LocalDateTime) parameter));
            else
                preparedStatement.setString(parameterIndex++, parameter != null ? parameter.toString() : null);
        }
    }
}
